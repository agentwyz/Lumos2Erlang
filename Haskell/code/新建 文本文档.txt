---类型类

--实现了Eq类
--相等
--类似于Java中的equals方法
5==6

class Eq a where
 (==) :: a -> a -> Bool
 (/=) :: a -> a -> Bool
 -- Defined in ‘GHC.Classes’
 instance (Eq a, Eq b) => Eq (Either a b)
 -- Defined in ‘Data.Either’
 instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
 instance Eq Word -- Defined in ‘GHC.Classes’
 instance Eq Ordering -- Defined in ‘GHC.Classes’


:t 5
:t (==)

--有序的类型类: Ord
--字符串其实是可以有序的
"Hello" < "World"


--enum
[1..10]


add3 :: (Int, Int, Int) -> Int
add3 (x, y, z) = x + y + z

add :: Int -> Int -> Int
add x y = x + y

--当有多个类型限定在一个类型上的时候
--他们需要使用=>

function2 :: Show a => Ord a => a -> a -> a

f :: Num a => a -> a
f x = 4 * x + 1

f' :: Num a => a -> a -> a
f' = \x -> \y -> 4 * x + 5 * y + 1

--a替换
\x -> \y -> x + y
\a -> \b -> a + b

--b化简
--参数到函数体的替换

--匿名表达式的应用
--1. 

map (\x -> 2 * x + 7) [1 .. 10]


--参数的绑定

--海伦公式
s :: Double -> Double -> Double
s a b c = let p = (a + b + c) / 2
            in sqrt (p * (p - a) * (p - c))

let f x = x + 1 in f 5
let x = 2; y = 2 in x + y

s' :: Double -> Double -> Double
s' a b c = sqrt (p)